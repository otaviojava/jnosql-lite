/*
*  Copyright (c) 2020 Ot√°vio Santana and others
*   All rights reserved. This program and the accompanying materials
*   are made available under the terms of the Eclipse Public License v1.0
*   and Apache License v2.0 which accompanies this distribution.
*   The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
*   and the Apache License v2.0 is available at http://www.opensource.org/licenses/apache2.0.php.
*
*   You may elect to redistribute this code under either of these licenses.
*
*   Contributors:
*
*   Otavio Santana
*/
package org.eclipse.jnosql.lite.mapping.metadata;

import jakarta.enterprise.context.ApplicationScoped;
import org.eclipse.jnosql.mapping.metadata.ClassInformationNotFoundException;
import org.eclipse.jnosql.mapping.metadata.EntitiesMetadata;
import org.eclipse.jnosql.mapping.metadata.EntityMetadata;
import org.eclipse.jnosql.mapping.metadata.InheritanceMetadata;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import javax.annotation.processing.Generated;

@Generated(value= "JNoSQL Lite EntitiesMetadata Generator", date = "{{now}}")
@ApplicationScoped
public final class DefaultEntitiesMetadata implements EntitiesMetadata {

    private static final Predicate<EntityMetadata> HAS_NAME = EntityMetadata::hasEntityName;

    private final List<EntityMetadata> entities;

    private final Map<String, EntityMetadata> findByClassName;

    private final Map<String, EntityMetadata> findBySimpleName;

    private final Map<Class<?>, EntityMetadata> classes;

    private final Map<String, EntityMetadata> mappings;


    public DefaultEntitiesMetadata() {
        this.findByClassName = new HashMap<>();
        this.findBySimpleName = new HashMap<>();
        this.classes = new HashMap<>();
        this.mappings = new HashMap<>();
        this.entities = new ArrayList<>();
    {{#entities}}
        this.entities.add(new {{.}}());
    {{/entities}}
    }

    @Override
    public EntityMetadata get(Class<?> entity) {
        Objects.requireNonNull(entity, "entity is required");
        return entities.stream()
                .filter(e -> entity.equals(e.type()))
                .findFirst()
                .orElseThrow(() -> new ClassInformationNotFoundException("Entity class not found: " + entity));
    }

    @Override
    public EntityMetadata findByName(String name) {
        Objects.requireNonNull(name, "name is required");
        return entities.stream()
                .filter(HAS_NAME.and(e -> name.equals(e.name())))
                .findFirst()
                .orElseThrow(() -> new ClassInformationNotFoundException("classEntity not found"));
    }

    @Override
    public Optional<EntityMetadata> findBySimpleName(String simpleName) {
        Objects.requireNonNull(simpleName, "simpleName is required");
        return entities.stream()
                .filter(e -> simpleName.equals(e.simpleName()))
                .findFirst();
    }

    @Override
    public Optional<EntityMetadata> findByClassName(String className) {
        Objects.requireNonNull(className, "className is required");
        return entities.stream()
                .filter(e -> className.equals(e.className()))
                .findFirst();
    }

   @Override
   public Optional<EntityMetadata> findByClass(Class<?> entity) {
       Objects.requireNonNull(entity, "entity is required");
       return entities.stream()
               .filter(e -> entity.equals(e.type()))
               .findFirst();
   }

   @Override
   public Map<String, InheritanceMetadata> findByParentGroupByDiscriminatorValue(Class<?> parent) {
       Objects.requireNonNull(parent, "parent is required");
       return this.entities.stream()
                .flatMap(c -> c.inheritance().stream())
                .filter(p -> p.isParent(parent))
                .collect(Collectors.toMap(i -> i.discriminatorValue(), Function.identity()));
   }
}